---
import Layout from "../layouts/common.astro";
---

<Layout title="Blog">
  <div
    class="mb-10 p-8 bg-white border border-gray-200 rounded-2xl shadow-sm flex flex-col text-left"
  >
    <p class="mb-2 text-gray-400 uppercase text-sm">Feb 22 2026</p>
    <h3 class="mt-4 text-3xl font-semibold text-gray-900">
      Getting Started with Pandas: A Minimal Guide for Python Developers
    </h3>

    <p class="mt-6 text-gray-500">
      Pandas is the go-to Python library for working with structured, tabular data — think
      spreadsheets, CSVs, or SQL tables, but in code. It sits at the heart of most data
      science and machine learning workflows, and learning it well pays off quickly.
    </p>

    <h4 class="mt-8 text-xl font-semibold text-gray-800">1. Installation</h4>
    <p class="mt-3 text-gray-500">
      Install pandas with pip inside your active virtual environment.
    </p>
    <div class="mt-3 bg-gray-50 border border-gray-200 rounded-lg p-4 text-sm font-mono text-gray-600">
      <p class="text-gray-400 text-xs uppercase mb-2">Shell</p>
      <p>pip install pandas</p>
    </div>

    <h4 class="mt-8 text-xl font-semibold text-gray-800">2. Core Data Structures</h4>
    <p class="mt-3 text-gray-500">
      Pandas has two primary building blocks: a <code class="bg-gray-100 px-1 rounded text-sm">Series</code> (a single 1D column)
      and a <code class="bg-gray-100 px-1 rounded text-sm">DataFrame</code> (a full 2D table). Almost everything you do will be on a DataFrame.
    </p>
    <div class="mt-3 bg-gray-50 border border-gray-200 rounded-lg p-4 text-sm font-mono text-gray-600">
      <p class="text-gray-400 text-xs uppercase mb-2">Example</p>
      <p>import pandas as pd</p>
      <p class="mt-3 text-gray-400"># Series — a single column</p>
      <p>s = pd.Series([10, 20, 30], index=['a', 'b', 'c'])</p>
      <p>print(s['b'])  <span class="text-gray-400"># 20</span></p>
      <p class="mt-3 text-gray-400"># DataFrame — a full table</p>
      <p>df = pd.DataFrame({'{'}</p>
      <p class="pl-4">'name':  ['Alice', 'Bob', 'Charlie'],</p>
      <p class="pl-4">'age':   [25, 30, 35],</p>
      <p class="pl-4">'score': [88.5, 92.0, 79.5]</p>
      <p>{'}'})</p>
    </div>

    <h4 class="mt-8 text-xl font-semibold text-gray-800">3. Selecting Data</h4>
    <p class="mt-3 text-gray-500">
      Pandas gives you multiple ways to select rows, columns, or individual cells.
      Use <code class="bg-gray-100 px-1 rounded text-sm">loc</code> for label-based access and
      <code class="bg-gray-100 px-1 rounded text-sm">iloc</code> for integer position — and use boolean conditions to filter rows.
    </p>
    <div class="mt-3 bg-gray-50 border border-gray-200 rounded-lg p-4 text-sm font-mono text-gray-600">
      <p class="text-gray-400 text-xs uppercase mb-2">Example</p>
      <p>df['name']           <span class="text-gray-400"># single column → Series</span></p>
      <p class="mt-1">df[['name', 'age']]  <span class="text-gray-400"># multiple columns → DataFrame</span></p>
      <p class="mt-3">df.loc[0]            <span class="text-gray-400"># row by label</span></p>
      <p class="mt-1">df.iloc[1]           <span class="text-gray-400"># row by integer position</span></p>
      <p class="mt-3">df[df['age'] > 28]   <span class="text-gray-400"># filter rows by condition</span></p>
    </div>

    <h4 class="mt-8 text-xl font-semibold text-gray-800">4. Exploring a DataFrame</h4>
    <p class="mt-3 text-gray-500">
      When you load a new dataset, these are the first methods to reach for. They give you a
      quick picture of shape, types, and statistical distribution before you touch the data.
    </p>
    <div class="mt-3 bg-gray-50 border border-gray-200 rounded-lg p-4 text-sm font-mono text-gray-600">
      <p class="text-gray-400 text-xs uppercase mb-2">Example</p>
      <p>df.head(5)      <span class="text-gray-400"># first N rows</span></p>
      <p class="mt-1">df.tail(5)      <span class="text-gray-400"># last N rows</span></p>
      <p class="mt-1">df.shape        <span class="text-gray-400"># (rows, cols)</span></p>
      <p class="mt-1">df.dtypes       <span class="text-gray-400"># column data types</span></p>
      <p class="mt-1">df.describe()   <span class="text-gray-400"># statistical summary</span></p>
    </div>

    <h4 class="mt-8 text-xl font-semibold text-gray-800">5. Adding & Modifying Columns</h4>
    <p class="mt-3 text-gray-500">
      You can derive new columns from existing ones using
      <code class="bg-gray-100 px-1 rounded text-sm">.apply()</code> for row-wise logic, or simple
      arithmetic for element-wise operations. Both happen without a loop.
    </p>
    <div class="mt-3 bg-gray-50 border border-gray-200 rounded-lg p-4 text-sm font-mono text-gray-600">
      <p class="text-gray-400 text-xs uppercase mb-2">Example</p>
      <p>df['grade'] = df['score'].apply(lambda x: 'A' if x >= 90 else 'B')</p>
      <p class="mt-1">df['age'] = df['age'] + 1  <span class="text-gray-400"># modify in place</span></p>
      <p class="mt-3">df['age'].mean()</p>
      <p class="mt-1">df.groupby('name')['score'].mean()</p>
    </div>

    <h4 class="mt-8 text-xl font-semibold text-gray-800">6. Handling Missing Data</h4>
    <p class="mt-3 text-gray-500">
      Real-world datasets almost always have gaps. Pandas represents missing values as
      <code class="bg-gray-100 px-1 rounded text-sm">NaN</code> and gives you tools to find, drop, or fill them.
    </p>
    <div class="mt-3 bg-gray-50 border border-gray-200 rounded-lg p-4 text-sm font-mono text-gray-600">
      <p class="text-gray-400 text-xs uppercase mb-2">Example</p>
      <p>df.isnull().sum()   <span class="text-gray-400"># count NaNs per column</span></p>
      <p class="mt-1">df.dropna()         <span class="text-gray-400"># drop rows containing any NaN</span></p>
      <p class="mt-1">df.fillna(0)        <span class="text-gray-400"># replace NaN with a default value</span></p>
    </div>

    <h4 class="mt-8 text-xl font-semibold text-gray-800">7. Reading, Writing & Merging</h4>
    <p class="mt-3 text-gray-500">
      Pandas reads most common file formats in one line. Merging DataFrames works like a SQL
      JOIN — specify the key column and the join type.
    </p>
    <div class="mt-3 bg-gray-50 border border-gray-200 rounded-lg p-4 text-sm font-mono text-gray-600">
      <p class="text-gray-400 text-xs uppercase mb-2">Example</p>
      <p>df = pd.read_csv('data.csv')</p>
      <p class="mt-1">df = pd.read_excel('data.xlsx')</p>
      <p class="mt-1">df.to_csv('output.csv', index=False)</p>
      <p class="mt-3">merged = pd.merge(df1, df2, on='id', how='inner')</p>
      <p class="mt-1">combined = pd.concat([df1, df2], ignore_index=True)</p>
    </div>

    <p class="mt-8 text-gray-500">
      The core shift when learning pandas is to think <span class="italic">column-first and vectorized</span> — avoid
      Python <code class="bg-gray-100 px-1 rounded text-sm">for</code> loops over rows, and let pandas operate on entire
      columns at once. It's faster, more readable, and more idiomatic. From here, pair
      pandas with <span class="font-medium text-gray-700">NumPy</span> for numerical computing or feed cleaned DataFrames
      directly into <span class="font-medium text-gray-700">scikit-learn</span> or <span class="font-medium text-gray-700">PyTorch</span> for machine learning.
    </p>
  </div>
</Layout>
